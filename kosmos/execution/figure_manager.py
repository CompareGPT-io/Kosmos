"""
Figure Manager for Kosmos research artifacts.

Coordinates figure generation and storage using PublicationVisualizer.
Implements Issue #60: Figure Generation from paper requirements.

Paper Claim (Section 5):
> "High-resolution figures: High-resolution plots generated by the Data Analysis Agent"

Features:
- Manages figure output paths under artifacts/cycle_N/figures/
- Maps analysis types to appropriate plot types
- Coordinates with PublicationVisualizer for publication-quality output
- Tracks figure metadata for reports
"""

import logging
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, asdict
import numpy as np

logger = logging.getLogger(__name__)


# Analysis type to plot type mapping
ANALYSIS_PLOT_MAPPING = {
    # Statistical tests
    't_test': 'box_plot_with_points',
    't-test': 'box_plot_with_points',
    'ttest': 'box_plot_with_points',
    'anova': 'box_plot_with_points',
    'mann_whitney': 'box_plot_with_points',
    'wilcoxon': 'box_plot_with_points',

    # Correlation/regression
    'correlation': 'scatter_with_regression',
    'regression': 'scatter_with_regression',
    'pearson': 'scatter_with_regression',
    'spearman': 'scatter_with_regression',
    'linear_regression': 'scatter_with_regression',

    # Scaling analysis
    'log_log': 'log_log_plot',
    'log-log': 'log_log_plot',
    'power_law': 'log_log_plot',
    'scaling': 'log_log_plot',

    # Distribution
    'distribution': 'violin_plot',
    'normality': 'qq_plot',
    'qq': 'qq_plot',

    # Multi-variable
    'heatmap': 'custom_heatmap',
    'correlation_matrix': 'custom_heatmap',
    'differential_expression': 'volcano_plot',
    'volcano': 'volcano_plot',

    # ML
    'ml': 'scatter_with_regression',
    'classification': 'scatter_with_regression',
    'prediction': 'scatter_with_regression',
}


@dataclass
class FigureMetadata:
    """Metadata for a generated figure."""
    path: str
    plot_type: str
    analysis_type: str
    dpi: int
    width: Optional[int] = None
    height: Optional[int] = None
    caption: Optional[str] = None
    cycle: Optional[int] = None
    task_id: Optional[int] = None

    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON serialization."""
        return asdict(self)


class FigureManager:
    """
    Manages figure generation and storage for research artifacts.

    Coordinates figure output paths, plot type selection, and metadata tracking.
    Uses PublicationVisualizer for actual rendering.

    Example:
        ```python
        from kosmos.execution.figure_manager import FigureManager

        manager = FigureManager(artifacts_dir=Path("./artifacts"))

        # Get output path for a figure
        path = manager.get_figure_path(cycle=1, task_id=3, plot_type="scatter")

        # Select appropriate plot type
        plot_type = manager.select_plot_type("correlation")

        # Generate figure with metadata tracking
        metadata = manager.generate_figure(
            data={'x': x_data, 'y': y_data},
            analysis_type='correlation',
            cycle=1,
            task_id=3,
            title="Correlation Analysis"
        )
        ```
    """

    def __init__(
        self,
        artifacts_dir: Union[str, Path],
        default_dpi: int = 300,
        use_visualizer: bool = True
    ):
        """
        Initialize FigureManager.

        Args:
            artifacts_dir: Base directory for artifacts
            default_dpi: Default DPI for figure output (300 for standard, 600 for panels)
            use_visualizer: Whether to initialize PublicationVisualizer
        """
        self.artifacts_dir = Path(artifacts_dir)
        self.default_dpi = default_dpi
        self.generated_figures: List[FigureMetadata] = []

        # Lazy load visualizer to avoid circular imports
        self._visualizer = None
        self._use_visualizer = use_visualizer

        logger.info(f"FigureManager initialized with artifacts_dir={artifacts_dir}")

    @property
    def visualizer(self):
        """Lazy load PublicationVisualizer."""
        if self._visualizer is None and self._use_visualizer:
            try:
                from kosmos.analysis.visualization import PublicationVisualizer
                self._visualizer = PublicationVisualizer()
                logger.info("PublicationVisualizer loaded")
            except ImportError as e:
                logger.warning(f"Could not import PublicationVisualizer: {e}")
                self._visualizer = None
        return self._visualizer

    def get_figures_dir(self, cycle: int) -> Path:
        """
        Get figures directory for a specific cycle.

        Creates the directory if it doesn't exist.

        Args:
            cycle: Research cycle number

        Returns:
            Path to figures directory
        """
        figures_dir = self.artifacts_dir / f"cycle_{cycle}" / "figures"
        figures_dir.mkdir(parents=True, exist_ok=True)
        return figures_dir

    def get_figure_path(
        self,
        cycle: int,
        task_id: int,
        plot_type: str,
        suffix: str = "png"
    ) -> Path:
        """
        Generate unique figure path.

        Format: artifacts/cycle_N/figures/task_M_plottype.png

        Args:
            cycle: Research cycle number
            task_id: Task identifier
            plot_type: Type of plot (e.g., "scatter", "box_plot")
            suffix: File extension (default: "png")

        Returns:
            Path to figure file
        """
        figures_dir = self.get_figures_dir(cycle)
        filename = f"task_{task_id}_{plot_type}.{suffix}"
        return figures_dir / filename

    def select_plot_type(
        self,
        analysis_type: str,
        n_groups: Optional[int] = None,
        n_variables: Optional[int] = None
    ) -> str:
        """
        Select appropriate plot type based on analysis type.

        Args:
            analysis_type: Type of analysis (e.g., "t_test", "correlation")
            n_groups: Number of groups (for group comparisons)
            n_variables: Number of variables (for multi-variable analysis)

        Returns:
            Plot type string (e.g., "box_plot_with_points", "scatter_with_regression")
        """
        # Normalize analysis type
        analysis_lower = analysis_type.lower().replace(' ', '_').replace('-', '_')

        # Check direct mapping
        if analysis_lower in ANALYSIS_PLOT_MAPPING:
            return ANALYSIS_PLOT_MAPPING[analysis_lower]

        # Check partial matches
        for key, plot_type in ANALYSIS_PLOT_MAPPING.items():
            if key in analysis_lower:
                return plot_type

        # Heuristics based on data shape
        if n_groups is not None and n_groups >= 2:
            if n_groups <= 4:
                return 'box_plot_with_points'
            else:
                return 'violin_plot'

        if n_variables is not None and n_variables >= 3:
            return 'custom_heatmap'

        # Default to box plot
        logger.warning(f"No plot type mapping for '{analysis_type}', defaulting to box_plot_with_points")
        return 'box_plot_with_points'

    def generate_figure(
        self,
        data: Dict[str, Any],
        analysis_type: str,
        cycle: int,
        task_id: int,
        title: Optional[str] = None,
        **kwargs
    ) -> Optional[FigureMetadata]:
        """
        Generate a figure and track metadata.

        Args:
            data: Data for plotting (format depends on plot type)
            analysis_type: Type of analysis
            cycle: Research cycle number
            task_id: Task identifier
            title: Optional plot title
            **kwargs: Additional arguments passed to plot method

        Returns:
            FigureMetadata if successful, None otherwise
        """
        if self.visualizer is None:
            logger.error("PublicationVisualizer not available")
            return None

        # Select plot type
        plot_type = self.select_plot_type(analysis_type)

        # Get output path
        output_path = self.get_figure_path(cycle, task_id, plot_type)

        # Get DPI (higher for log-log plots)
        dpi = 600 if plot_type == 'log_log_plot' else self.default_dpi

        try:
            # Route to appropriate visualization method
            result_path = self._render_figure(
                plot_type=plot_type,
                data=data,
                output_path=output_path,
                title=title or f"Task {task_id} - {analysis_type.replace('_', ' ').title()}",
                **kwargs
            )

            # Create metadata
            metadata = FigureMetadata(
                path=str(result_path),
                plot_type=plot_type,
                analysis_type=analysis_type,
                dpi=dpi,
                caption=kwargs.get('caption', f"Figure for {analysis_type} analysis"),
                cycle=cycle,
                task_id=task_id
            )

            self.generated_figures.append(metadata)
            logger.info(f"Generated figure: {result_path}")

            return metadata

        except Exception as e:
            logger.error(f"Failed to generate figure: {e}")
            return None

    def _render_figure(
        self,
        plot_type: str,
        data: Dict[str, Any],
        output_path: Path,
        title: str,
        **kwargs
    ) -> str:
        """
        Render figure using PublicationVisualizer.

        Args:
            plot_type: Type of plot to create
            data: Plot data
            output_path: Output file path
            title: Plot title
            **kwargs: Additional plot parameters

        Returns:
            Path to saved figure
        """
        viz = self.visualizer

        if plot_type == 'box_plot_with_points':
            return viz.box_plot_with_points(
                data=data.get('groups', data),
                title=title,
                y_label=kwargs.get('y_label', 'Value'),
                output_path=str(output_path)
            )

        elif plot_type == 'scatter_with_regression':
            return viz.scatter_with_regression(
                x=np.array(data.get('x', [])),
                y=np.array(data.get('y', [])),
                x_label=kwargs.get('x_label', 'X'),
                y_label=kwargs.get('y_label', 'Y'),
                title=title,
                output_path=str(output_path)
            )

        elif plot_type == 'log_log_plot':
            return viz.log_log_plot(
                x=np.array(data.get('x', [])),
                y=np.array(data.get('y', [])),
                x_label=kwargs.get('x_label', 'X'),
                y_label=kwargs.get('y_label', 'Y'),
                title=title,
                output_path=str(output_path)
            )

        elif plot_type == 'violin_plot':
            return viz.violin_plot(
                data=data.get('groups', data),
                title=title,
                y_label=kwargs.get('y_label', 'Value'),
                output_path=str(output_path)
            )

        elif plot_type == 'qq_plot':
            return viz.qq_plot(
                data=np.array(data.get('values', data.get('data', []))),
                title=title,
                output_path=str(output_path)
            )

        elif plot_type == 'custom_heatmap':
            return viz.custom_heatmap(
                data=np.array(data.get('matrix', [])),
                row_labels=data.get('row_labels', []),
                col_labels=data.get('col_labels', []),
                title=title,
                output_path=str(output_path)
            )

        elif plot_type == 'volcano_plot':
            return viz.volcano_plot(
                log2fc=np.array(data.get('log2fc', [])),
                p_values=np.array(data.get('p_values', [])),
                labels=data.get('labels'),
                title=title,
                output_path=str(output_path)
            )

        else:
            raise ValueError(f"Unknown plot type: {plot_type}")

    def get_figure_count(self) -> int:
        """Get total number of generated figures."""
        return len(self.generated_figures)

    def get_figures_for_cycle(self, cycle: int) -> List[FigureMetadata]:
        """Get all figures generated for a specific cycle."""
        return [f for f in self.generated_figures if f.cycle == cycle]

    def get_figure_paths(self) -> List[str]:
        """Get list of all generated figure paths."""
        return [f.path for f in self.generated_figures]

    def to_dict(self) -> Dict:
        """Serialize figure manager state to dictionary."""
        return {
            'artifacts_dir': str(self.artifacts_dir),
            'default_dpi': self.default_dpi,
            'figure_count': self.get_figure_count(),
            'figures': [f.to_dict() for f in self.generated_figures]
        }


def generate_code_figure_block(
    plot_type: str,
    group_var: Optional[str] = None,
    measure_var: Optional[str] = None,
    x_var: Optional[str] = None,
    y_var: Optional[str] = None,
    title: str = "Analysis Results"
) -> List[str]:
    """
    Generate code lines for figure creation in code templates.

    Used by code_generator.py to add figure generation to analysis templates.

    Args:
        plot_type: Type of plot to generate
        group_var: Group variable name (for group comparisons)
        measure_var: Measurement variable name (for group comparisons)
        x_var: X variable name (for scatter plots)
        y_var: Y variable name (for scatter plots)
        title: Plot title

    Returns:
        List of code lines to add to template
    """
    code_lines = [
        "",
        "# Generate publication-quality figure",
        "from kosmos.analysis.visualization import PublicationVisualizer",
        "viz = PublicationVisualizer()",
        ""
    ]

    if plot_type == 'box_plot_with_points':
        if group_var and measure_var:
            code_lines.extend([
                f"# Create data dictionary for box plot",
                f"groups = df['{group_var}'].unique()",
                f"plot_data = {{str(g): df[df['{group_var}']==g]['{measure_var}'].values for g in groups}}",
                "",
                f"# Generate box plot",
                f"if 'figure_path' in dir():",
                f"    viz.box_plot_with_points(",
                f"        data=plot_data,",
                f"        title='{title}',",
                f"        y_label='{measure_var}',",
                f"        output_path=str(figure_path)",
                f"    )",
                f"    results['figure_path'] = str(figure_path)",
            ])
        else:
            code_lines.extend([
                "# Box plot (requires group and measure variables)",
                "# plot_data = {'Group1': values1, 'Group2': values2}",
                "# viz.box_plot_with_points(data=plot_data, output_path=figure_path)",
            ])

    elif plot_type == 'scatter_with_regression':
        if x_var and y_var:
            code_lines.extend([
                f"# Generate scatter plot with regression",
                f"if 'figure_path' in dir():",
                f"    viz.scatter_with_regression(",
                f"        x=df['{x_var}'].values,",
                f"        y=df['{y_var}'].values,",
                f"        x_label='{x_var}',",
                f"        y_label='{y_var}',",
                f"        title='{title}',",
                f"        output_path=str(figure_path)",
                f"    )",
                f"    results['figure_path'] = str(figure_path)",
            ])
        else:
            code_lines.extend([
                "# Scatter plot (requires x and y variables)",
                "# viz.scatter_with_regression(x=x_data, y=y_data, output_path=figure_path)",
            ])

    elif plot_type == 'log_log_plot':
        if x_var and y_var:
            code_lines.extend([
                f"# Generate log-log plot",
                f"if 'figure_path' in dir():",
                f"    viz.log_log_plot(",
                f"        x=df['{x_var}'].values,",
                f"        y=df['{y_var}'].values,",
                f"        x_label='{x_var}',",
                f"        y_label='{y_var}',",
                f"        title='{title}',",
                f"        output_path=str(figure_path)",
                f"    )",
                f"    results['figure_path'] = str(figure_path)",
            ])
        else:
            code_lines.extend([
                "# Log-log plot (requires x and y variables)",
                "# viz.log_log_plot(x=x_data, y=y_data, output_path=figure_path)",
            ])

    return code_lines
